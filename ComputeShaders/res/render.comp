#version 460 core
#define PI 3.141592654

layout(local_size_x = 8, local_size_y = 1, local_size_z = 1) in;
struct Point{
vec4 pos;
vec4 oldPos;
vec4 vel;
vec4 extra;
};
layout(std430, binding = 0) buffer pts{
Point p[];
};

layout(std430, binding = 3) buffer verticesBuffer
{
    float vert[];
};

layout(std430, binding = 4) buffer indicesBuffer
{
    uint indices[];
};

void main()
{
    int POINT_COUNT = 6;
    int winx = 1480;
    int stepp = POINT_COUNT * 9;
    int stepi = POINT_COUNT * 3;
    uint pIndex = gl_GlobalInvocationID.x;
    float ratio = (PI*2.0) / float(POINT_COUNT);
    float radius = p[pIndex].extra.x / float(winx);
    float centerX = p[pIndex].pos.x / float(winx);
    float centerY = p[pIndex].pos.y / float(winx);
    if(pIndex >= p.length())return;
    else
    for(int i = 0; i < POINT_COUNT; i++)
    {
        uint idx = stepp * pIndex + i * 9;
        uint i2 = stepi * pIndex + i * 3;
        indices[i2] = i2;
        indices[i2+1] = i2+1;
        indices[i2+2] = i2+2;
        vert[idx] = centerX;
        vert[idx+1] = centerY;
        vert[idx+2] = 0;

        vert[idx+3] = centerX + cos(ratio*i) * radius;
        vert[idx+4] = centerY + sin(ratio*i) * radius;
        vert[idx+5] = 0;

        vert[idx+6] = centerX + cos(ratio*(i+1)) * radius;
        vert[idx+7] = centerY + sin(ratio*(i+1)) * radius;
        vert[idx+8] = 0;
    }
}
